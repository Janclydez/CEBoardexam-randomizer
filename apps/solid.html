<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solids of Revolution – Multi-Function</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f1f3f4;
    }
    #ui {
      width: 330px;
      padding: 16px;
      border-right: 1px solid #ddd;
      background: #fafafa;
      overflow-y: auto;
    }
    #viewer {
      flex: 1;
      background: #111;
    }
    h2 {
      margin: 0 0 10px;
      font-size: 1.2rem;
    }
    label {
      display: block;
      margin-top: 10px;
      font-weight: 600;
      font-size: 0.9rem;
    }
    input, select {
      width: 100%;
      padding: 6px 8px;
      margin-top: 3px;
      font-size: 0.9rem;
    }
    .small-note {
      font-size: 0.78rem;
      color: #555;
      margin-top: 3px;
    }
    .row {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }
    .row > div {
      flex: 1;
    }

    /* Desmos-style function list */
    #functionsList {
      margin-top: 8px;
    }
    .fn-row {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      margin-bottom: 6px;
      background: #fff;
      border-radius: 6px;
      box-shadow: 0 0 0 1px #e0e0e0;
    }
    .fn-color {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      margin-right: 6px;
      flex-shrink: 0;
    }
    .fn-label {
      margin-right: 4px;
      font-size: 0.9rem;
      flex-shrink: 0;
    }
    .fn-input {
      flex: 1;
      border: none;
      outline: none;
      font-family: Consolas, "Courier New", monospace;
      font-size: 0.9rem;
      background: transparent;
    }
    .fn-remove {
      margin-left: 6px;
      border: none;
      background: transparent;
      font-size: 1.1rem;
      cursor: pointer;
      color: #999;
      padding: 0 4px;
    }
    .fn-remove:hover {
      color: #e53935;
    }
    #addFnBtn {
      margin-top: 4px;
      padding: 6px 8px;
      width: 100%;
      border-radius: 4px;
      border: 1px dashed #bbb;
      background: #fff;
      cursor: pointer;
      font-size: 0.9rem;
    }
    #addFnBtn:hover {
      background: #f5f5f5;
    }

    button.main-btn {
      margin-top: 12px;
      padding: 8px 10px;
      width: 100%;
      font-size: 0.95rem;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #1a73e8;
      background: #1a73e8;
      color: white;
    }
    button.main-btn:hover {
      background: #1558b0;
    }

    input[type="range"] {
      width: 100%;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <h2>Solids of Revolution</h2>

    <label>Functions (Desmos-style list)</label>
    <div id="functionsList"></div>
    <button id="addFnBtn" type="button">+ Add function</button>
    <div class="small-note">
      Each row is <code>y = f(x)</code>. Examples: <code>x^2</code>, <code>sqrt(x)</code>, <code>sin(x)+1</code>
    </div>

    <div class="row">
      <div>
        <label>x-min:</label>
        <input id="xmin" value="0" />
      </div>
      <div>
        <label>x-max:</label>
        <input id="xmax" value="2" />
      </div>
    </div>

    <label>Axis of revolution:</label>
    <select id="axis">
      <option value="y=0">x-axis (y = 0)</option>
      <option value="x=0">y-axis (x = 0)</option>
      <option value="x=a">vertical line x = a</option>
      <option value="y=b">horizontal line y = b</option>
    </select>

    <label>Axis constant (a or b):</label>
    <input id="axisVal" value="2" />
    <div class="small-note">
      Used only for <code>x = a</code> or <code>y = b</code>.
    </div>

    <label>Sweep angle (0 to 2π):</label>
    <input type="range" id="sweep" min="0" max="6.283" step="0.01" value="6.283" />
    <div class="small-note">
      Current angle: <span id="sweepLabel">2π</span>
    </div>

    <button id="genBtn" class="main-btn" type="button">Generate / Update</button>

    <div class="small-note" style="margin-top:10px;">
      Controls:<br>
      • <b>Left-drag</b>: rotate view<br>
      • <b>Middle-drag (scroll button)</b>: pan<br>
      • <b>Mouse wheel</b>: zoom
    </div>
  </div>

  <div id="viewer"></div>

  <!-- Libraries -->
  <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjs@13.0.3/lib/browser/math.min.js"></script>

  <script>
    // ======== GLOBALS ========
    let scene, camera, renderer;
    let surfacesGroup;
    const colorPalette = ['#ff2d55', '#0f9d58', '#4285f4', '#f4b400', '#aa00ff', '#ff6d00'];

    // Simple camera orbit state
    let camRadius = 8;
    let camTheta = Math.PI / 4; // around vertical axis
    let camPhi   = Math.PI / 4; // from "top"
    const camTarget = new THREE.Vector3(0, 0, 0);

    // Mouse control state
    let isDragging = false;
    let dragButton = 0;
    let lastX = 0, lastY = 0;

    // ======== UI SETUP ========
    const fnListEl   = document.getElementById('functionsList');
    const addFnBtn   = document.getElementById('addFnBtn');
    const genBtn     = document.getElementById('genBtn');
    const sweepInput = document.getElementById('sweep');
    const sweepLabel = document.getElementById('sweepLabel');

    function addFunctionRow(initialExpr = '') {
      const idx   = fnListEl.children.length;
      const color = colorPalette[idx % colorPalette.length];

      const row = document.createElement('div');
      row.className = 'fn-row';
      row.dataset.color = color;

      const dot = document.createElement('span');
      dot.className = 'fn-color';
      dot.style.backgroundColor = color;

      const label = document.createElement('span');
      label.className = 'fn-label';
      label.textContent = 'y =';

      const input = document.createElement('input');
      input.type  = 'text';
      input.className = 'fn-input';
      input.placeholder = 'f(x)';
      input.value = initialExpr;

      const remove = document.createElement('button');
      remove.type = 'button';
      remove.className = 'fn-remove';
      remove.textContent = '×';
      remove.addEventListener('click', () => {
        fnListEl.removeChild(row);
        updateSolids();
      });

      row.appendChild(dot);
      row.appendChild(label);
      row.appendChild(input);
      row.appendChild(remove);
      fnListEl.appendChild(row);
    }

    // Prepopulate with two functions like in your screenshot
    addFunctionRow('x^2');
    addFunctionRow('2*x');

    addFnBtn.addEventListener('click', () => {
      addFunctionRow('');
    });

    genBtn.addEventListener('click', () => {
      updateSolids();
    });

    sweepInput.addEventListener('input', () => {
      const val = parseFloat(sweepInput.value);
      sweepLabel.textContent = (Math.abs(val - 6.283) < 0.01) ? '2π' : val.toFixed(2);
      updateSolids();
    });

    // ======== 3D INIT ========
    init3D();
    updateSolids();
    animate();

    function init3D() {
      const viewer = document.getElementById('viewer');

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(viewer.clientWidth, window.innerHeight);
      viewer.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);

      camera = new THREE.PerspectiveCamera(
        45,
        viewer.clientWidth / window.innerHeight,
        0.1,
        1000
      );
      updateCameraPosition();

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
      dirLight.position.set(8, 10, 5);
      scene.add(dirLight);

      // Axes + grid for reference
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);

      const grid = new THREE.GridHelper(12, 24, 0x555555, 0x333333);
      grid.position.y = 0;
      scene.add(grid);

      surfacesGroup = new THREE.Group();
      scene.add(surfacesGroup);

      // Resize handling
      window.addEventListener('resize', onWindowResize);

      // Mouse controls
      const canvas = renderer.domElement;
      canvas.addEventListener('mousedown', onMouseDown);
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('wheel', onMouseWheel, { passive: false });
    }

    function updateCameraPosition() {
      const sinPhi = Math.sin(camPhi);
      const cosPhi = Math.cos(camPhi);

      const x = camTarget.x + camRadius * sinPhi * Math.cos(camTheta);
      const y = camTarget.y + camRadius * cosPhi;
      const z = camTarget.z + camRadius * sinPhi * Math.sin(camTheta);

      camera.position.set(x, y, z);
      camera.lookAt(camTarget);
    }

    function onWindowResize() {
      const viewer = document.getElementById('viewer');
      camera.aspect = viewer.clientWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(viewer.clientWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // ======== MOUSE CONTROLS ========
    function onMouseDown(e) {
      isDragging = true;
      dragButton = e.button; // 0=left, 1=middle, 2=right
      lastX = e.clientX;
      lastY = e.clientY;
    }

    function onMouseMove(e) {
      if (!isDragging) return;

      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      if (dragButton === 0) {
        // Rotate
        const rotSpeed = 0.005;
        camTheta -= dx * rotSpeed;
        camPhi   -= dy * rotSpeed;
        const eps = 0.05;
        camPhi = Math.max(eps, Math.min(Math.PI - eps, camPhi));
        updateCameraPosition();
      } else if (dragButton === 1) {
        // Middle button – pan
        panCamera(dx, dy);
      }
    }

    function onMouseUp() {
      isDragging = false;
    }

    function onMouseWheel(e) {
      e.preventDefault();
      const delta = e.deltaY;
      const zoomFactor = 1 + delta * 0.001;
      camRadius *= zoomFactor;
      camRadius = Math.max(1, Math.min(100, camRadius));
      updateCameraPosition();
    }

    function panCamera(dx, dy) {
      // Move target & camera sideways in the view plane
      const panSpeed = camRadius * 0.002;

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir); // from camera to scene

      const up = new THREE.Vector3(0, 1, 0);
      const right = new THREE.Vector3().crossVectors(dir, up).normalize();
      const trueUp = new THREE.Vector3().crossVectors(right, dir).normalize();

      camTarget.addScaledVector(right, -dx * panSpeed);
      camTarget.addScaledVector(trueUp,  dy * panSpeed);
      updateCameraPosition();
    }

    // ======== SOLIDS GENERATION ========
    function updateSolids() {
      // Remove old group
      if (surfacesGroup) {
        scene.remove(surfacesGroup);
      }
      surfacesGroup = new THREE.Group();
      scene.add(surfacesGroup);

      const xmin = parseFloat(document.getElementById('xmin').value);
      const xmax = parseFloat(document.getElementById('xmax').value);
      const axisType = document.getElementById('axis').value;
      const axisConst = parseFloat(document.getElementById('axisVal').value);
      const sweepAngle = parseFloat(document.getElementById('sweep').value);

      if (!isFinite(xmin) || !isFinite(xmax) || xmin >= xmax) {
        console.warn('Invalid x-range');
        return;
      }

      const rows = Array.from(fnListEl.querySelectorAll('.fn-row'));
      if (!rows.length) return;

      for (const row of rows) {
        const input = row.querySelector('.fn-input');
        const expr  = input.value.trim();
        if (!expr) continue;

        let compiled;
        try {
          compiled = math.parse(expr).compile();
        } catch (err) {
          console.warn('Error parsing', expr, err);
          continue;
        }

        const color = row.dataset.color || '#ffffff';
        const mesh  = buildSurfaceForFunction(
          compiled, xmin, xmax, sweepAngle, axisType, axisConst, color
        );
        if (mesh) surfacesGroup.add(mesh);
      }
    }

    function buildSurfaceForFunction(fCompiled, xmin, xmax, sweepAngle, axisType, axisConst, color) {
      const resX = 80;
      const resT = 80;

      const positions = [];
      const indices = [];

      for (let i = 0; i <= resX; i++) {
        const u = i / resX;
        const x = xmin + u * (xmax - xmin);

        let y;
        try {
          y = fCompiled.evaluate({ x: x });
        } catch {
          y = NaN;
        }
        if (!isFinite(y)) y = 0;

        for (let j = 0; j <= resT; j++) {
          const v = j / resT;
          const t = sweepAngle * v;

          const p = revolvePoint(x, y, axisType, axisConst, t);
          positions.push(p.X, p.Y, p.Z);
        }
      }

      const stride = resT + 1;
      for (let i = 0; i < resX; i++) {
        for (let j = 0; j < resT; j++) {
          const a = i * stride + j;
          const b = (i + 1) * stride + j;
          const c = (i + 1) * stride + (j + 1);
          const d = i * stride + (j + 1);

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geom.setIndex(indices);
      geom.computeVertexNormals();

      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color(color),
        transparent: true,
        opacity: 0.78,
        side: THREE.DoubleSide
      });

      return new THREE.Mesh(geom, material);
    }

    function revolvePoint(x, y, axisType, axisConst, t) {
      let X, Y, Z;

      if (axisType === 'y=0') {
        // x-axis: y = 0
        const b = 0;
        const r = y - b;
        X = x;
        Y = b + r * Math.cos(t);
        Z = r * Math.sin(t);
      } else if (axisType === 'y=b') {
        const b = axisConst;
        const r = y - b;
        X = x;
        Y = b + r * Math.cos(t);
        Z = r * Math.sin(t);
      } else if (axisType === 'x=0') {
        // y-axis: x = 0
        const a = 0;
        const r = x - a;
        X = a + r * Math.cos(t);
        Y = y;
        Z = r * Math.sin(t);
      } else if (axisType === 'x=a') {
        const a = axisConst;
        const r = x - a;
        X = a + r * Math.cos(t);
        Y = y;
        Z = r * Math.sin(t);
      } else {
        X = x;
        Y = y;
        Z = 0;
      }

      return { X, Y, Z };
    }
  </script>
</body>
</html>
