<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quiz Maker (Single File)</title>

  <style>
:root { font-family: system-ui, Arial, sans-serif; }
body { margin: 0; background: #0b1220; color: #e8eefc; }
.wrap { max-width: 1200px; margin: 0 auto; padding: 18px; }
.top h1 { margin: 0 0 10px; }
.row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
.label { opacity: .9; }
.hint { opacity: .7; margin: 10px 0 0; }

.grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px; }
@media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }

.card { background: #111a2e; border: 1px solid rgba(255,255,255,.08); border-radius: 14px; overflow: hidden; }
.cardHead { display: flex; align-items: center; justify-content: space-between; padding: 14px 14px; border-bottom: 1px solid rgba(255,255,255,.08); }
.cardHead h2 { margin: 0; font-size: 16px; opacity: .95; }

.btn { background: #1c2a4b; color: #e8eefc; border: 1px solid rgba(255,255,255,.10); border-radius: 10px; padding: 8px 12px; cursor: pointer; }
.btn:disabled { opacity: .45; cursor: not-allowed; }
.btn.primary { background: #2e66ff; border-color: rgba(255,255,255,.15); }

.editor, .output { padding: 14px; min-height: 520px; }
.muted { opacity: .8; }

.field { margin-bottom: 12px; }
.field label { display: block; font-size: 12px; opacity: .85; margin-bottom: 6px; }
textarea, input[type="text"], input[type="number"] {
  width: 100%; box-sizing: border-box;
  background: #0b1220; color: #e8eefc;
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 10px; padding: 10px;
}
textarea { min-height: 80px; resize: vertical; }

.subq { border: 1px solid rgba(255,255,255,.10); border-radius: 12px; padding: 12px; margin: 12px 0; }
.subqHead { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
.subqHead h3 { margin: 0; font-size: 14px; }
.small { font-size: 12px; opacity: .8; }

.choices { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
@media (max-width: 700px) { .choices { grid-template-columns: 1fr; } }

.imagesZone { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
.thumbList { margin-top: 10px; display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; }
@media (max-width: 700px) { .thumbList { grid-template-columns: repeat(2, minmax(0, 1fr)); } }

.thumb {
  background: #0b1220;
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 12px;
  padding: 8px;
}
.thumb[draggable="true"] { cursor: grab; }
.thumb img { width: 100%; height: 120px; object-fit: cover; border-radius: 10px; display: block; }
.thumb .meta { display: flex; justify-content: space-between; align-items: center; margin-top: 6px; gap: 8px; }
.thumb .meta span { font-size: 11px; opacity: .85; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.thumb .meta button { padding: 4px 8px; border-radius: 8px; }

.paper { background: #f6f7fb; color: #111; border-radius: 12px; padding: 14px; }
.paper h3 { margin: 0 0 10px; }
.paper .prob { border-top: 1px solid #ddd; padding-top: 12px; margin-top: 12px; }
.paper .prob:first-child { border-top: none; padding-top: 0; margin-top: 0; }
.paper .imgRow { display: flex; gap: 8px; flex-wrap: wrap; margin: 8px 0; }
.paper .imgRow img { max-width: 220px; border-radius: 10px; border: 1px solid #ccc; }
.paper .opts { margin: 6px 0 0; padding-left: 18px; }
.paper .opts li { margin: 2px 0; }

  /* --- Equation PNGs (Output tab only) --- */
  .paper img.eqPng{
    height: 1.2em;
    vertical-align: -0.25em;
    display: inline-block;
  }
  .paper img.eqPng.block{
    display:block;
    height:auto;
    max-height: 90px;
    margin: 6px 0;
  }

  /* Output controls */
  .outControls{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .outControls .btn{ padding: 7px 10px; border-radius: 10px; }
  .pill{ display:inline-block; font-size:12px; opacity:.85; border:1px solid rgba(255,255,255,.12); border-radius:999px; padding:3px 10px; }

  /* Answer key box */
  .keyBox{ margin-top:12px; background:#0b1220; color:#e8eefc; border:1px solid rgba(255,255,255,.10); border-radius:12px; padding:10px; }
  .keyBox pre{ margin:0; white-space:pre-wrap; word-break:break-word; }

  /* Slightly tighter paper lists */
  .paper .qItem{ margin-top:10px; }
  .paper .qItem:first-child{ margin-top:0; }
  </style>

  <!-- MathJax: used ONLY to convert $...$ equations into PNG images in the OUTPUT pane -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$','$$']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>
  <div class="wrap">
    <header class="top">
      <h1>Quiz Maker</h1>

      <div class="row">
        <label class="label">No. of problems (max 75)</label>
        <input id="numQuestions" type="number" min="1" max="75" value="1" />
        <button id="btnStart" class="btn">Start</button>
        <button id="btnGenerate" class="btn primary" disabled>Generate Exam</button>
        <span id="statusPill" class="pill" style="display:none;">Generating…</span>
      </div>
      <p class="hint">Use <b>$...$</b> for equations. They will be converted into PNG <b>only</b> in the Output panel (Editor stays plain text).</p>
    </header>

    <main class="grid">
      <!-- Editor -->
      <section class="card">
        <div class="cardHead">
          <h2 id="editorTitle">Editor</h2>
          <div class="nav">
            <button id="btnPrev" class="btn" disabled>◀ Prev</button>
            <button id="btnNext" class="btn" disabled>Next ▶</button>
          </div>
        </div>

        <div id="editor" class="editor muted">
          Click <b>Start</b> to create problems.
        </div>
      </section>

      <!-- Output -->
      <section class="card">
        <div class="cardHead">
          <h2>Output (Randomized)</h2>
          <div class="outControls">
            <button id="btnToggleKey" class="btn" disabled>Show Answer Key</button>
            <button id="btnCopyKey" class="btn" disabled>Copy Answer Key</button>
            <button id="btnCopyWord" class="btn" disabled>Copy Output (Word)</button>
          </div>
        </div>

        <div id="output" class="output muted">
          Output will appear here after you click <b>Generate Exam</b>.
        </div>
      </section>
    </main>
  </div>

  <script>
    // ---------------------------
    // Utilities
    // ---------------------------
    const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
    const uid = () => (crypto.randomUUID ? crypto.randomUUID() : ("id_" + Math.random().toString(16).slice(2)));

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function escapeHtml(s) {
      return (s ?? "").replace(/[&<>"']/g, (m) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
    }

    function fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(String(r.result));
        r.onerror = reject;
        r.readAsDataURL(file);
      });
    }

    function idxToLetter(i) {
      return String.fromCharCode(65 + i);
    }

    // ---------------------------
    // Math: $...$ -> PNG (OUTPUT ONLY)
    // ---------------------------
    const _eqCache = new Map(); // latex -> dataUrl

    async function ensureMathJaxReady() {
      if (!window.MathJax) throw new Error("MathJax not loaded.");
      if (MathJax.startup?.promise) await MathJax.startup.promise;
    }

    async function latexToPngDataUrl(latex, opts = {}) {
      const key = (latex ?? "").trim();
      if (!key) return "";
      if (_eqCache.has(key)) return _eqCache.get(key);

      await ensureMathJaxReady();

      const scale = opts.scale ?? 2;
      const padding = opts.padding ?? 12;
      const display = !!opts.display;
      const background = opts.background ?? "transparent";

      const svg = MathJax.tex2svg(key, { display }).querySelector("svg");
      if (!svg) throw new Error("Failed to build SVG from LaTeX: " + key);

      svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      const svgText = new XMLSerializer().serializeToString(svg);

      const vb = svg.getAttribute("viewBox");
      let w = 0, h = 0;
      if (vb) {
        const parts = vb.split(/\s+/).map(Number);
        w = parts[2]; h = parts[3];
      } else {
        w = 600; h = 200;
      }

      const blob = new Blob([svgText], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const img = new Image();
      img.decoding = "async";

      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = () => reject(new Error("SVG load failed (equation): " + key));
        img.src = url;
      });
      URL.revokeObjectURL(url);

      const canvas = document.createElement("canvas");
      canvas.width = Math.ceil((w + padding * 2) * scale);
      canvas.height = Math.ceil((h + padding * 2) * scale);
      const ctx = canvas.getContext("2d");

      if (background !== "transparent") {
        ctx.fillStyle = background;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      ctx.setTransform(scale, 0, 0, scale, 0, 0);
      ctx.drawImage(img, padding, padding);

      const dataUrl = canvas.toDataURL("image/png");
      _eqCache.set(key, dataUrl);
      return dataUrl;
    }

    // Replace $...$ with <img> PNGs. Supports escaping: \$ for literal dollar.
    async function renderTextWithEquationPngs(raw) {
      const s = String(raw ?? "");
      if (!s.includes("$")) return escapeHtml(s).replaceAll("\\$", "$");

      const parts = [];
      let i = 0;

      const pushText = (t) => { if (t) parts.push({ type: "text", value: t }); };
      const pushEq = (t) => { if (t !== undefined) parts.push({ type: "eq", value: t }); };

      while (i < s.length) {
        // find next unescaped $
        let start = -1;
        for (let k = i; k < s.length; k++) {
          if (s[k] === "$" && s[k - 1] !== "\\") { start = k; break; }
        }
        if (start === -1) { pushText(s.slice(i)); break; }

        pushText(s.slice(i, start));

        // find closing $
        let end = -1;
        for (let k = start + 1; k < s.length; k++) {
          if (s[k] === "$" && s[k - 1] !== "\\") { end = k; break; }
        }
        if (end === -1) { pushText(s.slice(start)); break; }

        pushEq(s.slice(start + 1, end));
        i = end + 1;
      }

      const out = [];
      for (const p of parts) {
        if (p.type === "text") {
          out.push(escapeHtml(p.value).replaceAll("\\$", "$"));
        } else {
          const dataUrl = await latexToPngDataUrl(p.value, { scale: 2, padding: 12, background: "transparent" });
          out.push(`<img class="eqPng" src="${dataUrl}" alt="${escapeHtml(p.value)}" />`);
        }
      }
      return out.join("");
    }

    // ---------------------------
    // State
    // ---------------------------
    let quiz = null;
    let currentIndex = 0;

    // Output state (after generation)
    let lastAnswerKey = "";
    let keyVisible = false;

    // ---------------------------
    // Elements
    // ---------------------------
    const numQuestions = document.getElementById("numQuestions");
    const btnStart = document.getElementById("btnStart");
    const btnGenerate = document.getElementById("btnGenerate");
    const btnPrev = document.getElementById("btnPrev");
    const btnNext = document.getElementById("btnNext");
    const editor = document.getElementById("editor");
    const output = document.getElementById("output");
    const editorTitle = document.getElementById("editorTitle");
    const statusPill = document.getElementById("statusPill");

    const btnToggleKey = document.getElementById("btnToggleKey");
    const btnCopyKey = document.getElementById("btnCopyKey");
    const btnCopyWord = document.getElementById("btnCopyWord");

    // ---------------------------
    // Init
    // ---------------------------
    numQuestions.addEventListener("input", () => {
      numQuestions.value = clamp(parseInt(numQuestions.value || "1", 10), 1, 75);
    });

    btnStart.addEventListener("click", () => {
      const n = clamp(parseInt(numQuestions.value || "1", 10), 1, 75);

      quiz = {
        title: "Quiz",
        count: n,
        problems: Array.from({ length: n }, () => ({
          situation: "",
          images: [],
          items: [makeItem()]
        }))
      };

      currentIndex = 0;
      btnGenerate.disabled = false;
      btnPrev.disabled = false;
      btnNext.disabled = false;
      renderEditor();
      renderNavState();

      // reset output controls
      btnToggleKey.disabled = true;
      btnCopyKey.disabled = true;
      btnCopyWord.disabled = true;
      keyVisible = false;
      lastAnswerKey = "";
      btnToggleKey.textContent = "Show Answer Key";
    });

    btnPrev.addEventListener("click", () => {
      if (!quiz) return;
      currentIndex = clamp(currentIndex - 1, 0, quiz.count - 1);
      renderEditor();
      renderNavState();
    });

    btnNext.addEventListener("click", () => {
      if (!quiz) return;
      currentIndex = clamp(currentIndex + 1, 0, quiz.count - 1);
      renderEditor();
      renderNavState();
    });

    btnGenerate.addEventListener("click", async () => {
      if (!quiz) return;
      await renderOutputRandomized();
    });

    btnToggleKey.addEventListener("click", () => {
      keyVisible = !keyVisible;
      updateKeyVisibility();
    });

    btnCopyKey.addEventListener("click", async () => {
      if (!lastAnswerKey) return;
      await navigator.clipboard.writeText(lastAnswerKey);
      toast("Answer key copied.");
    });

    btnCopyWord.addEventListener("click", async () => {
      const examNode = document.getElementById("paperExam");
      if (!examNode) return;
      await copyNodeAsRichHtml(examNode);
      toast("Output copied (paste into Word).");
    });

    // ---------------------------
    // Builders
    // ---------------------------
    function makeItem() {
      return {
        question: "",
        // index 0 = correct answer, 1-3 = distractors
        options: ["", "", "", ""]
      };
    }

    // ---------------------------
    // Editor
    // ---------------------------
    function renderNavState() {
      if (!quiz) return;
      btnPrev.disabled = currentIndex === 0;
      btnNext.disabled = currentIndex === quiz.count - 1;
      editorTitle.textContent = `Editor — Problem ${currentIndex + 1} of ${quiz.count}`;
    }

    function renderEditor() {
      if (!quiz) return;
      const p = quiz.problems[currentIndex];

      editor.classList.remove("muted");
      editor.innerHTML = `
        <div class="field">
          <label>Problem / Situation</label>
          <textarea id="situationInput" placeholder="Type the main statement here... Use $...$ for equations."></textarea>
        </div>

        <div class="field">
          <label>Upload Images (multiple)</label>
          <div class="imagesZone">
            <input id="imgInput" type="file" accept="image/*" multiple />
            <span class="small">Drag thumbnails to reorder</span>
          </div>
          <div id="thumbList" class="thumbList"></div>
        </div>

        <div class="field">
          <div class="row" style="justify-content:space-between;">
            <label style="margin:0;">Items (per problem)</label>
            <button id="addItem" class="btn">+ Add Item</button>
          </div>
          <div id="itemList"></div>
        </div>
      `;

      // Situation
      const situationInput = document.getElementById("situationInput");
      situationInput.value = p.situation;
      situationInput.addEventListener("input", () => { p.situation = situationInput.value; });

      // Images
      const imgInput = document.getElementById("imgInput");
      imgInput.addEventListener("change", async (e) => {
        const files = Array.from(e.target.files || []);
        for (const f of files) {
          if (!f.type.startsWith("image/")) continue;
          const dataUrl = await fileToDataUrl(f);
          p.images.push({ id: uid(), name: f.name, dataUrl });
        }
        imgInput.value = "";
        renderThumbs();
      });

      // Add item
      document.getElementById("addItem").addEventListener("click", () => {
        p.items.push(makeItem());
        renderItemList();
      });

      renderThumbs();
      renderItemList();
      renderNavState();

      function renderThumbs() {
        const thumbList = document.getElementById("thumbList");
        thumbList.innerHTML = p.images.map((img) => `
          <div class="thumb" draggable="true" data-id="${img.id}">
            <img src="${img.dataUrl}" alt="${escapeHtml(img.name)}" />
            <div class="meta">
              <span title="${escapeHtml(img.name)}">${escapeHtml(img.name)}</span>
              <button class="btn" data-del="${img.id}">Remove</button>
            </div>
          </div>
        `).join("");

        // Remove
        thumbList.querySelectorAll("button[data-del]").forEach(btn => {
          btn.addEventListener("click", () => {
            const id = btn.getAttribute("data-del");
            p.images = p.images.filter(x => x.id !== id);
            renderThumbs();
          });
        });

        // Drag reorder
        let dragId = null;
        thumbList.querySelectorAll(".thumb").forEach(node => {
          node.addEventListener("dragstart", (ev) => {
            dragId = node.getAttribute("data-id");
            ev.dataTransfer.effectAllowed = "move";
          });

          node.addEventListener("dragover", (ev) => {
            ev.preventDefault();
            ev.dataTransfer.dropEffect = "move";
          });

          node.addEventListener("drop", (ev) => {
            ev.preventDefault();
            const dropId = node.getAttribute("data-id");
            if (!dragId || dragId === dropId) return;

            const from = p.images.findIndex(x => x.id === dragId);
            const to = p.images.findIndex(x => x.id === dropId);
            const [moved] = p.images.splice(from, 1);
            p.images.splice(to, 0, moved);

            dragId = null;
            renderThumbs();
          });
        });
      }

      function renderItemList() {
        const itemList = document.getElementById("itemList");
        itemList.innerHTML = p.items.map((it, idx) => `
          <div class="subq" data-idx="${idx}">
            <div class="subqHead">
              <h3>Item ${idx + 1}</h3>
              <div class="row" style="gap:8px;">
                <span class="small">Correct + 3 choices</span>
                <button class="btn" data-remove-item="${idx}" ${p.items.length === 1 ? "disabled" : ""}>Remove</button>
              </div>
            </div>

            <div class="field" style="margin-top:10px;">
              <label>Question</label>
              <textarea data-q placeholder="Type the question here... Use $...$ for equations."></textarea>
            </div>

            <div class="choices">
              <div class="field">
                <label>Correct Answer</label>
                <input type="text" data-opt="0" placeholder="Correct answer... Use $...$ for equations." />
              </div>
              <div class="field">
                <label>Choice 1</label>
                <input type="text" data-opt="1" placeholder="Choice 1... Use $...$ for equations." />
              </div>
              <div class="field">
                <label>Choice 2</label>
                <input type="text" data-opt="2" placeholder="Choice 2... Use $...$ for equations." />
              </div>
              <div class="field">
                <label>Choice 3</label>
                <input type="text" data-opt="3" placeholder="Choice 3... Use $...$ for equations." />
              </div>
            </div>
          </div>
        `).join("");

        // Bind inputs
        itemList.querySelectorAll(".subq").forEach(block => {
          const idx = parseInt(block.getAttribute("data-idx"), 10);
          const it = p.items[idx];

          const qta = block.querySelector("textarea[data-q]");
          qta.value = it.question;
          qta.addEventListener("input", () => { it.question = qta.value; });

          block.querySelectorAll("input[data-opt]").forEach(inp => {
            const oi = parseInt(inp.getAttribute("data-opt"), 10);
            inp.value = it.options[oi] ?? "";
            inp.addEventListener("input", () => { it.options[oi] = inp.value; });
          });
        });

        // Remove
        itemList.querySelectorAll("button[data-remove-item]").forEach(btn => {
          btn.addEventListener("click", () => {
            const idx = parseInt(btn.getAttribute("data-remove-item"), 10);
            if (p.items.length <= 1) return;
            p.items.splice(idx, 1);
            renderItemList();
          });
        });
      }
    }

    // ---------------------------
    // Output
    // ---------------------------
    async function renderOutputRandomized() {
      output.classList.remove("muted");
      statusPill.style.display = "inline-block";
      btnGenerate.disabled = true;
      btnToggleKey.disabled = true;
      btnCopyKey.disabled = true;
      btnCopyWord.disabled = true;

      output.innerHTML = `
        <div class="paper">
          <div class="small">Generating… converting $...$ equations to PNG (Output only)…</div>
        </div>
      `;

      try {
        // Randomize problem order
        const randomizedProblems = shuffle(quiz.problems).map((p, probIdx) => ({
          situation: p.situation,
          images: p.images,
          items: p.items, // keep item order within problem
          number: probIdx + 1
        }));

        // total items across all problems
        const totalItems = randomizedProblems.reduce((sum, p) => sum + p.items.length, 0);

        let examHtml = `
          <div class="paper" id="paperExam">
            <h3>${escapeHtml(quiz.title)} — Generated Exam</h3>
            <div class="small">Problems: ${randomizedProblems.length} • Total Items: <b>${totalItems}</b> (problem order randomized)</div>
        `;

        let itemNo = 0;
        const keyLines = [];

        for (const p of randomizedProblems) {
          const situationHtml = await renderTextWithEquationPngs(p.situation);

          examHtml += `
            <div class="prob">
              <div><b>Problem ${p.number}.</b> ${situationHtml}</div>

              ${p.images.length ? `
                <div class="imgRow">
                  ${p.images.map(img => `<img src="${img.dataUrl}" alt="${escapeHtml(img.name)}" />`).join("")}
                </div>
              ` : ""}
          `;

          for (const it of p.items) {
            itemNo += 1;

            const qHtml = await renderTextWithEquationPngs(it.question);

            // options: correct + 3 distractors
            const raw = (it.options || ["","","",""]).map(x => String(x ?? ""));
            const packed = raw.map((t, i) => ({ text: t, isCorrect: i === 0 }));
            const shuffledOpts = shuffle(packed);

            const correctIdx = shuffledOpts.findIndex(o => o.isCorrect);
            const correctLetter = idxToLetter(correctIdx);

            keyLines.push(`${itemNo} - ${correctLetter}`);

            const liHtml = (await Promise.all(shuffledOpts.map(async (o) => {
              const chHtml = await renderTextWithEquationPngs(o.text);
              return `<li>${chHtml}</li>`;
            }))).join("");

            examHtml += `
              <div class="qItem">
                <div><b>${itemNo}.</b> ${qHtml}</div>
                <ol class="opts" type="A">
                  ${liHtml}
                </ol>
              </div>
            `;
          }

          examHtml += `</div>`; // prob
        }

        examHtml += `</div>`; // paperExam

        lastAnswerKey = keyLines.join("\n");
        keyVisible = false;
        btnToggleKey.textContent = "Show Answer Key";

        output.innerHTML = `
          ${examHtml}
          <div class="keyBox" id="keyBox" style="display:none;">
            <b>Answer Key</b>
            <div class="small">Format: itemNumber - letter</div>
            <pre id="keyPre"></pre>
          </div>
        `;
        document.getElementById("keyPre").textContent = lastAnswerKey;

        // enable controls
        btnToggleKey.disabled = false;
        btnCopyKey.disabled = false;
        btnCopyWord.disabled = false;

      } catch (e) {
        output.innerHTML = `
          <div class="paper">
            <b>Error:</b> ${escapeHtml(e.message)}
          </div>
        `;
      } finally {
        statusPill.style.display = "none";
        btnGenerate.disabled = false;
      }
    }

    function updateKeyVisibility() {
      const box = document.getElementById("keyBox");
      if (!box) return;
      box.style.display = keyVisible ? "block" : "none";
      btnToggleKey.textContent = keyVisible ? "Hide Answer Key" : "Show Answer Key";
    }

    // ---------------------------
    // Copy (Word)
    // ---------------------------
    async function copyNodeAsRichHtml(node) {
      const html = node.outerHTML;
      const text = node.innerText;

      if (navigator.clipboard && window.ClipboardItem) {
        const item = new ClipboardItem({
          "text/html": new Blob([html], { type: "text/html" }),
          "text/plain": new Blob([text], { type: "text/plain" })
        });
        await navigator.clipboard.write([item]);
      } else {
        // fallback
        await navigator.clipboard.writeText(text);
      }
    }

    // ---------------------------
    // Toast (tiny)
    // ---------------------------
    let _toastTimer = null;
    function toast(msg) {
      statusPill.textContent = msg;
      statusPill.style.display = "inline-block";
      clearTimeout(_toastTimer);
      _toastTimer = setTimeout(() => {
        statusPill.style.display = "none";
        statusPill.textContent = "Generating…";
      }, 1100);
    }
  </script>
</body>
</html>
